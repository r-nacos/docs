import{_ as s,c as n,aq as r,j as l,a as t,G as o,w as e,B as p,o as d}from"./chunks/framework.CNcA2yo8.js";const T=JSON.parse('{"title":"架构","description":"","frontmatter":{},"headers":[],"relativePath":"architecture/index.md","filePath":"zh/architecture/index.md","lastUpdated":1738043441000}'),c={name:"architecture/index.md"};function h(_,a,f,g,u,m){const i=p("VPNolebaseInlineLinkPreview");return d(),n("div",null,[a[8]||(a[8]=r('<h1 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h1><h2 id="r-nacos架构图" tabindex="-1">r-nacos架构图 <a class="header-anchor" href="#r-nacos架构图" aria-label="Permalink to &quot;r-nacos架构图&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/r-nacos/r-nacos/master/doc/assets/imgs/r-nacos_L2_0.3.7.svg" alt="架构图" loading="lazy"></p><p>说明：</p>',4)),l("ul",null,[a[3]||(a[3]=l("li",null,"r-nacos默认支持集群部署，单机就相当于一个节点的集群，后续有需要可以按需加入新的节点；",-1)),a[4]||(a[4]=l("li",null,"数据持久化使用raft协议分布式数据库(raft协议+节点文件存储),类似etcd;",-1)),a[5]||(a[5]=l("li",null,[t("只需对"),l("code",null,"RNACOS_CONFIG_DB_DIR:nacos_db"),t("目录下的文件备份与恢复，即可实现数据的备份与恢复；")],-1)),l("li",null,[a[1]||(a[1]=t("r-nacos控制台使用前后端分离架构；前端应用因依赖nodejs,所以单独放到另一个项目 ")),o(i,{href:"https://github.com/r-nacos/rnacos-console-web",target:"_blank",rel:"noreferrer"},{default:e(()=>a[0]||(a[0]=[t("r-nacos-console-web")])),_:1}),a[2]||(a[2]=t(" ,再通过cargo 把打包好的前端资源引入到本项目,避免开发rust时还要依赖nodejs。"))])]),a[9]||(a[9]=r('<p>多实例的raft和distro分布式协议说明待补充</p><h2 id="配置中心" tabindex="-1">配置中心 <a class="header-anchor" href="#配置中心" aria-label="Permalink to &quot;配置中心&quot;">​</a></h2><p>配置模型图</p><p><img src="https://github.com/heqingpan/rnacos/raw/master/doc/assets/imgs/rnacos_L4_config001_LR.svg" alt="" loading="lazy"></p><h2 id="配置中心raft协议" tabindex="-1">配置中心raft协议 <a class="header-anchor" href="#配置中心raft协议" aria-label="Permalink to &quot;配置中心raft协议&quot;">​</a></h2><p>raft协议的主要逻辑：</p><ol><li>节点区分角色：leader(主节点),follower(从节点),candidate(选举节点);</li><li>稳定状态是一个主节点，多个从节点；</li><li>主节点负责写入，写入时需要先把写入日志同步到其它节点，超过半数节点写入日志成功后才能提交日志到状态机。</li><li>主节点需要定时发心跳到从节点，从节点如果超时未收到心跳，则会发起选举。选举时收到超过半数节点的同意，就可以切换成主节点。</li></ol>',7)),l("p",null,[a[7]||(a[7]=t("具体协议可以参考 ")),o(i,{href:"https://docs.qq.com/doc/DY0VxSkVGWHFYSlZJ",target:"_blank",rel:"noreferrer"},{default:e(()=>a[6]||(a[6]=[t("raft协议论文")])),_:1})]),a[10]||(a[10]=r('<p>r-nacos 接入 raft的主要逻辑：</p><ol><li>基于 async-raft 库实现raft协议，主要实现网络层和存储层。在 r-nacos中存储层的状态机就是配置中心。</li><li>配置中心接入raft 协议的状态机，由 raft 状态机驱动更新配置中心的内容。</li></ol><p>r-nacos一个三节点的配置中心请求处理示例：</p><p><img src="https://github.com/heqingpan/rnacos/raw/master/doc/assets/imgs/20230917182416.png" alt="" loading="lazy"></p><p>写入:</p><ol><li>客户端随机向一个节点发起一个更新配置请求</li><li>在请求入口层加一个raft路由判断，如果本节点是主节点则处理，否则路由到指定主节点处理</li><li>主节点写入请求到raft日志</li><li>将请求同步到其它从节点</li><li>如果超过半数节点写入日志成功（包含自身），则提交请求日志到状态机中，配置写入配置中心。（其它从节点的提交在下次日志同步或心跳时提交）</li><li>返回处理结果</li></ol><p>请求：</p><ol><li>客户端随机向一个节点发起一个查询配置请求</li><li>收到请求的节点和单机处理一样，直接查询本节点配置中心数据返回。</li></ol><h2 id="注册中心类distro协议" tabindex="-1">注册中心类distro协议 <a class="header-anchor" href="#注册中心类distro协议" aria-label="Permalink to &quot;注册中心类distro协议&quot;">​</a></h2><p>协议主要逻辑：</p><ol><li>每个节点有全量的数据，都可提供注册信息查询服务。</li><li>注册中心每个节点平等，按hash划分每个节点负责的内容；节点对负责的服务可写，否则转发到对应负责的节点处理。</li><li>通过 grpc协议注册的服务，接收的节点直接处理。</li><li>一个节点更新服务实例信息后再同步给其它节点。</li></ol><p>具体协议可以参考java nacos 的distro协议实现 。 r-nacos 和 java版主体逻辑相同，但实现的细节有些区别。</p><p>r-nacos一个三节点的注册中心请求处理示例：</p><p><img src="https://github.com/heqingpan/rnacos/raw/master/doc/assets/imgs/20230917182622.png" alt="" loading="lazy"></p><p>http 写入：</p><ol><li>客户端随机向一个节点发起一个注册服务实例请求</li><li>请求跳过服务路由判断，如果服务路由的节点是本节点则处理，否则路由到指定的其它节点处理</li><li>收到本节点负责的服务实例请求，把请求注册到注册中心中</li><li>返回处理结果</li><li>异步同步更新的数据到其它节点</li></ol><p>grpc 写入（不路由，本节点直接处理）：</p><ol><li>客户端随机向一个节点发起grpc长链接</li><li>客户端发起一个注册服务实例请求</li><li>像单机一样，把请求注册到注册中心中</li><li>返回处理结果</li><li>异步同步更新的数据到其它节点</li></ol><p>查询：</p><ol><li>客户端随机向一个节点发起一个查询服务信息请求</li><li>收到请求的节点和单机处理一样，直接查询本节点注册中心数据返回。</li></ol><h3 id="为什么http的写入与grpc写入的路由逻辑不同" tabindex="-1">为什么http的写入与grpc写入的路由逻辑不同？ <a class="header-anchor" href="#为什么http的写入与grpc写入的路由逻辑不同" aria-label="Permalink to &quot;为什么http的写入与grpc写入的路由逻辑不同？&quot;">​</a></h3><p>因为grpc的心跳是按长链接来处理，一个客户端的链接段开，则这个链接的所用请求都失效。【高效】</p><p>然后http的实例注册是无状态的，只能通过定时器按注册时间更新实例的状态；同时注册中心中实例是按服务分类维护的。 所以http注册的实例需要按服务做路由，这样才能支持不同的节点负责不同范围的服务。【低效】</p><p>所以在注册中心使用grpc协议的性能会比http协议性能好很多。</p><p>注：部分内容待补充</p>',25))])}const q=s(c,[["render",h]]);export{T as __pageData,q as default};
