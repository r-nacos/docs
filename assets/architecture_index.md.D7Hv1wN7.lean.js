import{_ as l,o as r,c as i,a6 as t}from"./chunks/framework.-anpL5na.js";const g=JSON.parse('{"title":"架构","description":"","frontmatter":{},"headers":[],"relativePath":"architecture/index.md","filePath":"zh/architecture/index.md","lastUpdated":1733968575000}'),o={name:"architecture/index.md"};function e(s,a,c,n,p,h){return r(),i("div",null,a[0]||(a[0]=[t('<h1 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h1><h2 id="r-nacos架构图" tabindex="-1">r-nacos架构图 <a class="header-anchor" href="#r-nacos架构图" aria-label="Permalink to &quot;r-nacos架构图&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/r-nacos/r-nacos/master/doc/assets/imgs/r-nacos_L2_0.3.7.svg" alt="架构图" loading="lazy"></p><p>说明：</p><ul><li>r-nacos默认支持集群部署，单机就相当于一个节点的集群，后续有需要可以按需加入新的节点；</li><li>数据持久化使用raft协议分布式数据库(raft协议+节点文件存储),类似etcd;</li><li>只需对<code>RNACOS_CONFIG_DB_DIR:nacos_db</code>目录下的文件备份与恢复，即可实现数据的备份与恢复；</li><li>r-nacos控制台使用前后端分离架构；前端应用因依赖nodejs,所以单独放到另一个项目 <a href="https://github.com/r-nacos/rnacos-console-web" target="_blank" rel="noreferrer">r-nacos-console-web</a> ,再通过cargo 把打包好的前端资源引入到本项目,避免开发rust时还要依赖nodejs。</li></ul><p>多实例的raft和distro分布式协议说明待补充</p><h2 id="配置中心" tabindex="-1">配置中心 <a class="header-anchor" href="#配置中心" aria-label="Permalink to &quot;配置中心&quot;">​</a></h2><p>配置模型图</p><p><img src="https://github.com/heqingpan/rnacos/raw/master/doc/assets/imgs/rnacos_L4_config001_LR.svg" alt="" loading="lazy"></p><h2 id="配置中心raft协议" tabindex="-1">配置中心raft协议 <a class="header-anchor" href="#配置中心raft协议" aria-label="Permalink to &quot;配置中心raft协议&quot;">​</a></h2><p>raft协议的主要逻辑：</p><ol><li>节点区分角色：leader(主节点),follower(从节点),candidate(选举节点);</li><li>稳定状态是一个主节点，多个从节点；</li><li>主节点负责写入，写入时需要先把写入日志同步到其它节点，超过半数节点写入日志成功后才能提交日志到状态机。</li><li>主节点需要定时发心跳到从节点，从节点如果超时未收到心跳，则会发起选举。选举时收到超过半数节点的同意，就可以切换成主节点。</li></ol><p>具体协议可以参考 <a href="https://docs.qq.com/doc/DY0VxSkVGWHFYSlZJ" target="_blank" rel="noreferrer">raft协议论文</a></p><p>r-nacos 接入 raft的主要逻辑：</p><ol><li>基于 async-raft 库实现raft协议，主要实现网络层和存储层。在 r-nacos中存储层的状态机就是配置中心。</li><li>配置中心接入raft 协议的状态机，由 raft 状态机驱动更新配置中心的内容。</li></ol><p>r-nacos一个三节点的配置中心请求处理示例：</p><p><img src="https://github.com/heqingpan/rnacos/raw/master/doc/assets/imgs/20230917182416.png" alt="" loading="lazy"></p><p>写入:</p><ol><li>客户端随机向一个节点发起一个更新配置请求</li><li>在请求入口层加一个raft路由判断，如果本节点是主节点则处理，否则路由到指定主节点处理</li><li>主节点写入请求到raft日志</li><li>将请求同步到其它从节点</li><li>如果超过半数节点写入日志成功（包含自身），则提交请求日志到状态机中，配置写入配置中心。（其它从节点的提交在下次日志同步或心跳时提交）</li><li>返回处理结果</li></ol><p>请求：</p><ol><li>客户端随机向一个节点发起一个查询配置请求</li><li>收到请求的节点和单机处理一样，直接查询本节点配置中心数据返回。</li></ol><h2 id="注册中心类distro协议" tabindex="-1">注册中心类distro协议 <a class="header-anchor" href="#注册中心类distro协议" aria-label="Permalink to &quot;注册中心类distro协议&quot;">​</a></h2><p>协议主要逻辑：</p><ol><li>每个节点有全量的数据，都可提供注册信息查询服务。</li><li>注册中心每个节点平等，按hash划分每个节点负责的内容；节点对负责的服务可写，否则转发到对应负责的节点处理。</li><li>通过 grpc协议注册的服务，接收的节点直接处理。</li><li>一个节点更新服务实例信息后再同步给其它节点。</li></ol><p>具体协议可以参考java nacos 的distro协议实现 。 r-nacos 和 java版主体逻辑相同，但实现的细节有些区别。</p><p>r-nacos一个三节点的注册中心请求处理示例：</p><p><img src="https://github.com/heqingpan/rnacos/raw/master/doc/assets/imgs/20230917182622.png" alt="" loading="lazy"></p><p>http 写入：</p><ol><li>客户端随机向一个节点发起一个注册服务实例请求</li><li>请求跳过服务路由判断，如果服务路由的节点是本节点则处理，否则路由到指定的其它节点处理</li><li>收到本节点负责的服务实例请求，把请求注册到注册中心中</li><li>返回处理结果</li><li>异步同步更新的数据到其它节点</li></ol><p>grpc 写入（不路由，本节点直接处理）：</p><ol><li>客户端随机向一个节点发起grpc长链接</li><li>客户端发起一个注册服务实例请求</li><li>像单机一样，把请求注册到注册中心中</li><li>返回处理结果</li><li>异步同步更新的数据到其它节点</li></ol><p>查询：</p><ol><li>客户端随机向一个节点发起一个查询服务信息请求</li><li>收到请求的节点和单机处理一样，直接查询本节点注册中心数据返回。</li></ol><h3 id="为什么http的写入与grpc写入的路由逻辑不同" tabindex="-1">为什么http的写入与grpc写入的路由逻辑不同？ <a class="header-anchor" href="#为什么http的写入与grpc写入的路由逻辑不同" aria-label="Permalink to &quot;为什么http的写入与grpc写入的路由逻辑不同？&quot;">​</a></h3><p>因为grpc的心跳是按长链接来处理，一个客户端的链接段开，则这个链接的所用请求都失效。【高效】</p><p>然后http的实例注册是无状态的，只能通过定时器按注册时间更新实例的状态；同时注册中心中实例是按服务分类维护的。 所以http注册的实例需要按服务做路由，这样才能支持不同的节点负责不同范围的服务。【低效】</p><p>所以在注册中心使用grpc协议的性能会比http协议性能好很多。</p><p><strong>待补充...</strong></p>',38)]))}const f=l(o,[["render",e]]);export{g as __pageData,f as default};
